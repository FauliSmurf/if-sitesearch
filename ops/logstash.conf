input {
    #stdin {}
    gelf {
    }
    #file {
    #  path =>  ["/usr/share/logstash/pipeline/if-sitesearch.log"]
    #}
}
filter {
    grok {
        match => {
            "message" => [
            "^.+ %{LOGLEVEL:log_level} .+siteId: %{UUID:siteId}"
            ]
        }
    }

    if [message] =~ "query-fragment:" {
        grok {
            match => {
                "message" => "^.+query-fragment: %{WORD:query-fragment} .+autocompletes: %{NUMBER:autocompletes:int}$"
            }
            add_tag => [ "autocomplete" ]
            #            break_on_match => true
        }
    }

    if [message] =~ "query:" {
        grok {
            match => {
                "message" => "^.+query: %{WORD:query} .+results: %{NUMBER:results:int}$"
            }
            add_tag => [ "search" ]
            #            break_on_match => true
        }
    }

    if [message] =~ "bodySize" {
        grok {
            match => {
                "message" => "^.+bodySize: %{NUMBER:bodySize:int} .+titleSize: %{NUMBER:titleSize:int} .+URL: %{URI:url}$"
            }
            add_tag => [ "index" ]
            #        break_on_match => true
        }
    }

    # if log line contains tab character followed by "at" then we will tag that entry as stacktrace
    if [message] =~ "\tat" {
        grok {
            match => ["message", "^(\tat)"]
            add_tag => [ "stacktrace" ]
        }
    }
}

output {
    elasticsearch {
        hosts => [ "ops-elasticsearch", "ops-elasticsearch-opt" ]
    }
}
